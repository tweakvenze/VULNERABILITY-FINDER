#include "../../include/exploit/buffer_overflow.h"

// [TODO:] if there is a segmentation fault look for vector in function "buffer_on_inputfield"


std::vector<std::string> page_address;

void Buffer_overflow::getstring(){
	std::string test_char = "B";
	for(size_t i = 0; i < test_string_inc_size; i++){
		test_string += test_char;
	}
	test_string_curr_size += test_string_inc_size;
	if(test_string_curr_size > 100) STOP_OVERFLOW = true;
}

Buffer_overflow::Buffer_overflow(std::string &hostname, int PORT_NUMBER, void *lock, std::string &line){
	this->hostname = hostname;
	buffer_overflow_sock = new Sock(hostname, PORT_NUMBER);
	test_string_curr_size = test_string_int_size;
	has_submit_value_field = false;
	this->PORT_NUMBER = PORT_NUMBER;
	page_method = 0; // 0 for Get Method 1 for Post Method
	STOP_OVERFLOW = false;
	this->lock =  (pthread_mutex_t *)lock;
	this->line = line;
}

inline void Buffer_overflow::print_buffer_overflow(std::string &message,int COLOR){
	pthread_mutex_lock(this->lock);
	print(message, COLOR);
	pthread_mutex_unlock(this->lock);
}

/* Get as close as possible to this function for possiblity of cracking and matching a string actually find the perfect string*/
void Buffer_overflow::getTempString(){
	std::string temp_string = "B" ,data = "";
	get_data_field(data);
	buffer_overflow_sock = new Sock(hostname, PORT_NUMBER);
	buffer_overflow_sock->POST_sendrequest(line,response,data.c_str());
	parse_html_code(response,headers,status_code);
	temp_string = response;
}

void Buffer_overflow::get_data_field(std::string &data){
	try{	size_t i;
			for (i = 0;i < return_vector.size(); i++)
				data += return_vector[i] + "=" + test_string + "&";
			data += extra_data;
		}
		catch (const std::out_of_range & ex)
		{
		    std::cout << "out_of_range Exception Caught :: " << ex.what() << NEW_LINE;
		}
		catch(...){
			std::cout <<"Get data field error" << NEW_LINE;
		}
}

void Buffer_overflow::get_Request(){
	/*get request*/
	std::string data, path;
	while(!STOP_OVERFLOW){
		//login.php?return_vector[0]={string}&return_vector[1]={string}&return_vector[i]={string}
		data = line + "?";
		getstring();
		get_data_field(data);
		buffer_overflow_sock = new Sock(hostname, PORT_NUMBER);
		buffer_overflow_sock->sendrequest(path, response);
		if(response.size() > 0){
			parse_html_code(response, headers, status_code);
			if (!response_filter(response, temp_string)){
				data = "Buffer Overflow with :: "+ line +"::size::"+ std::to_string(test_string_curr_size)+"::data::"+ path;
				print_buffer_overflow(data,2);
				break;
			}
			else {
				data = "Same Response";
				print_buffer_overflow(data, 2);
			}
		}
	}
}

void Buffer_overflow::post_Request(){
	std::string data = "";
	test_string.clear();
	test_string_curr_size = test_string_int_size;
	getTempString();
	while(!STOP_OVERFLOW){
		getstring();
		get_data_field(data);
		buffer_overflow_sock = new Sock(hostname, PORT_NUMBER);
		buffer_overflow_sock->POST_sendrequest(line,response,data.c_str());
		if(response.size() > 0){
			parse_html_code(response,headers,status_code);
			if (!response_filter(response, temp_string)){
				data = "Buffer Overflow with :: "+ line +"::size::"+ std::to_string(test_string_curr_size)+"::data::"+ data;
				print_buffer_overflow(data, 2);
				break;
			}
		else {
				data = "same response";
				print_buffer_overflow(data, 4);
			}
		}
		data = "";
	}
}

void Buffer_overflow::buffer_on_inputfield(){
	std::string page_action = "";
	buffer_overflow_sock = new Sock(hostname, PORT_NUMBER);
	buffer_overflow_sock->sendrequest(line, response);
	parse_html_code(response, headers, status_code);
	temp_string = response;
	has_input_field = false;
	search_for_input_field(response, return_vector, has_input_field, page_method,page_action);
	size_t pop_values = 0 , vector_size = return_vector.size();
	if(vector_size >= 6) pop_values = 4;
	else if(vector_size >= 4) pop_values = 2;
	else if(vector_size >= 2) pop_values = 3;  // I wanted to run loop for once without breaking it so i get this with 3 value only
	if(pop_values){
		for(size_t i = vector_size - 1; i > vector_size - pop_values; i =  i-2){
			extra_data += return_vector[i - 1] + "=" + return_vector[i] + "&";
			return_vector.pop_back();
			return_vector.pop_back();
		}
		extra_data.pop_back();
	}
	if(has_input_field){
		if(page_method)
			post_Request();
		else
			get_Request();
	}
}

void *bufferoverflow_Threads(void *thread_data){
	struct thread_data *this_thread_data = (struct thread_data *) thread_data;
	Buffer_overflow *buffer;
	std::string page_add;
	while(1){
		pthread_mutex_lock(&this_thread_data->lock);
		if(page_address.empty()){
			print ("Done all pages Breaking",4);
			pthread_mutex_unlock(&this_thread_data->lock);
			break;
		}
		page_add = page_address.back();
		page_address.pop_back();
		pthread_mutex_unlock(&this_thread_data->lock);
		buffer = new Buffer_overflow(this_thread_data->hostname,this_thread_data->PORT_NUMBER,&this_thread_data->lock, page_add);
		buffer->buffer_on_inputfield();
		free(buffer);
	}
	pthread_exit(NULL);
}

void Buffer_overflow_init(std::string &hostname, int PORT_NUMBER, int THREADS){
		std::ifstream fin;
		std::string line,filename = Save_LOCATION;
		filename += hostname + FILE_EXTENSION;

		int begin, rc,status_code = 0,flag = 0;
		pthread_t threads[THREADS];
		pthread_mutex_t lock;
		struct thread_data td[THREADS];
		fin.open(filename);
		if (!fin.is_open()){
			print ("Host has no file saved or not collected any data from information step",1);
			return;
		}
		while(std::getline(fin, line)){
			if(line == ">>>> GoBuster Results "){
				flag = 1;
			}
			else if(line == "<<<<" && flag == 1)
					break;
			else if(flag == 1){
				begin = line.find(": ");

				/* Uncomment following two lines for not checking files with 3** html status code*/
		 		status_code = std::atoi(line.substr(begin + 2,1).c_str());
				if (status_code == 3) continue;

				begin = line.find(" (");
				line.replace(begin, (int) line.size(), "");
				page_address.push_back(line);
		}
	}
	if(pthread_mutex_init(&lock ,NULL) != 0){
		 print("Mutex init failed", 1);
		 return;
	}
	print("Buffer Overflow traversal ...",6);
	for (int i = 0; i < THREADS; i++){
		td[i].thread_id = i;
		td[i].hostname = hostname;
		td[i].PORT_NUMBER = PORT_NUMBER;
		td[i].lock = lock;

		rc = pthread_create(&threads[i], NULL, bufferoverflow_Threads, &td[i]);
		if (rc){
			print("Error:unable to create thread,"+ std::to_string(rc), 1);
			break;
		}
	}
	print ("Thread Created Attacking ..",4);
	for (int i = 0; i < THREADS; i++)
				pthread_join(threads[i], NULL);
	pthread_mutex_destroy(&lock);
	pthread_exit(NULL);
}
