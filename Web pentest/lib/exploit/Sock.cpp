#include "../../include/exploit/Sock.h"

Sock::Sock(std::string &hostname,int PORT){
    struct protoent *protoent;
    in_addr_t in_addr;

    struct hostent *hostent;
    struct sockaddr_in sockaddr_in;
    unsigned short server_port = PORT;

	#if defined(_WIN32) || defined(_WIN64)
    	WSADATA wsa;
    	if (WSAStartup(MAKEWORD(2,2),&wsa) != 0) {
    		printf("\nError: Windows socket subsytsem could not be initialized. Error Code: %d. Exiting..\n", WSAGetLastError());
    		exit(1);
    	}
	#endif

    /* Build the socket. */
    protoent = getprotobyname("tcp");
    if (protoent == NULL) {
        perror("getprotobyname");
        exit(EXIT_FAILURE);
    }
    sock = socket(AF_INET, SOCK_STREAM, protoent->p_proto);
    if (sock == -1) {
        perror("socket");
        exit(EXIT_FAILURE);
    }

    /* Build the address. */
    hostent = gethostbyname(hostname.c_str());
    if (hostent == NULL) {
        fprintf(stderr, "error: gethostbyname(\"%s\")\n", hostname.c_str());
        exit(EXIT_FAILURE);
    }
    in_addr = inet_addr(inet_ntoa(*(struct in_addr*)*(hostent->h_addr_list)));
    if (in_addr == (in_addr_t)-1) {
        fprintf(stderr, "error: inet_addr(\"%s\")\n", *(hostent->h_addr_list));
        exit(EXIT_FAILURE);
    }
    sockaddr_in.sin_addr.s_addr = in_addr;
    sockaddr_in.sin_family = AF_INET;
    sockaddr_in.sin_port = htons(server_port);

    /* Actually connect. */
    if (connect(sock, (struct sockaddr*)&sockaddr_in, sizeof(sockaddr_in)) == -1) {
        perror("connect");
        exit(EXIT_FAILURE);
    }
    this->hostname = hostname;
    this->sockaddr_in = sockaddr_in;
}

void Sock::POST_sendrequest(std::string &path, std::string &Response,const char * data){
	Response.clear();
	char request_template[PACKET_SIZE];
	snprintf(request_template,PACKET_SIZE,"POST %s HTTP/1.1\r\nHost: %s\r\nUser-Agent: curl/7.74.0\r\nAccept: */*\r\nContent-Length: %ld\r\nContent-Type: application/x-www-form-urlencoded\r\n\r\n%s",path.c_str(),hostname.c_str(), strlen(data),data);
	char request[PACKET_SIZE];
	int request_len = snprintf(request, PACKET_SIZE, request_template, hostname);
	if (request_len >= PACKET_SIZE) {
	        fprintf(stderr, "request length large: %d\n", request_len);
	        exit(EXIT_FAILURE);
	}
	ssize_t nbytes_total, nbytes_last;
	char buffer[BUFSIZ];
	memset(buffer, 0, strlen(buffer));
	/* Send HTTP request. */
	nbytes_total = 0;
	while (nbytes_total < request_len) {
		nbytes_last = write(sock, request + nbytes_total, request_len - nbytes_total);
		if (nbytes_last == -1) {
			perror("write");
			exit(EXIT_FAILURE);
		}
		nbytes_total += nbytes_last;
	}
	/* Read the response. */
	while ((nbytes_total = read(sock, buffer, BUFSIZ)) > 0) {
		Response += std::string(buffer);
		if (strlen(buffer) > MAX_FILE_SIZE)
			break;
	}
	if (nbytes_total == -1) {
		perror("read");
		exit(EXIT_FAILURE);
	}
}

void Sock::POST_sendThroughProxy(std::string &path, std::string &Response, int port, std::string &h_name,char  *data){
	Response.clear();
	char request_template[PACKET_SIZE];
	snprintf(request_template,PACKET_SIZE,"POST http://%s HTTP/1.1\r\nHost: %s\r\nAccept: */*\r\nContent-Length: %ld\r\nContent-Type: application/x-www-form-urlencoded\r\nProxy-Connection: Keep-Alive\r\n\r\n%s",path.c_str(),h_name.c_str(), strlen(data),data);
	char request[PACKET_SIZE];
		int request_len = snprintf(request, PACKET_SIZE, request_template, hostname);
		if (request_len >= PACKET_SIZE) {
		        fprintf(stderr, "request length large: %d\n", request_len);
		        exit(EXIT_FAILURE);
		}
		ssize_t nbytes_total, nbytes_last;
		char buffer[BUFSIZ];
		memset(buffer, 0, strlen(buffer));
		/* Send HTTP request. */
		nbytes_total = 0;
		while (nbytes_total < request_len) {
			nbytes_last = write(sock, request + nbytes_total, request_len - nbytes_total);
			if (nbytes_last == -1) {
				perror("write");
				exit(EXIT_FAILURE);
			}
			nbytes_total += nbytes_last;
		}
		/* Read the response. */
		while ((nbytes_total = read(sock, buffer, BUFSIZ)) > 0) {
			if (nbytes_total > 0){
				Response += std::string(buffer);
				if (Response.size() > MAX_FILE_SIZE)
					break;
			}
			else
					break;
		}
		if (nbytes_total == -1) {
			perror("read");
			return;
		}
}

void Sock::sendrequest(std::string &path, std::string &Response){
	Response.clear();
	char request_template[PACKET_SIZE];
	snprintf(request_template,PACKET_SIZE,"GET %s HTTP/1.1\r\nHost: %s\r\nConnection: close\r\n\r\n",path.c_str(),hostname.c_str());
	char request[PACKET_SIZE];
	int request_len = snprintf(request, PACKET_SIZE, request_template, hostname);
	if (request_len >= PACKET_SIZE) {
	        fprintf(stderr, "request length large: %d\n", request_len);
	        exit(EXIT_FAILURE);
	}
	ssize_t nbytes_total, nbytes_last;
	char buffer[BUFSIZ];

	memset(buffer, 0, strlen(buffer));
	/* Send HTTP request. */
	nbytes_total = 0;
	while (nbytes_total < request_len) {
		nbytes_last = write(sock, request + nbytes_total, request_len - nbytes_total);
		if (nbytes_last == -1) {
			perror("write");
			exit(EXIT_FAILURE);
		}
		nbytes_total += nbytes_last;
	}
	/* Read the response. */
	while ((nbytes_total = read(sock, buffer, BUFSIZ)) > 0) {
		Response += std::string(buffer);
		//write(STDOUT_FILENO, buffer, nbytes_total);
		if (Response.size() > MAX_FILE_SIZE)
			break;
	}
	if (nbytes_total == -1) {
		perror("read");
		return;
	}
}
void Sock::sendThroughProxy(std::string &path, std::string &Response, int port, std::string &h_name){
	Response.clear();
	char request_template[PACKET_SIZE];
	snprintf(request_template,PACKET_SIZE,"GET http://%s HTTP/1.1\r\nHost: %s\r\nUser-Agent: curl/7.74.0\r\nAccept: text/html\r\nProxy-Connection: Keep-Alive\r\n\r\n",path.c_str(),h_name.c_str());
	char request[PACKET_SIZE];
		int request_len = snprintf(request, PACKET_SIZE, request_template, hostname);
		if (request_len >= PACKET_SIZE) {
		        fprintf(stderr, "request length large: %d\n", request_len);
		        exit(EXIT_FAILURE);
		}
		ssize_t nbytes_total, nbytes_last;
		char buffer[BUFSIZ];
		memset(buffer, 0, strlen(buffer));
		/* Send HTTP request. */
		nbytes_total = 0;
		while (nbytes_total < request_len) {
			nbytes_last = write(sock, request + nbytes_total, request_len - nbytes_total);
			if (nbytes_last == -1) {
				perror("write");
				exit(EXIT_FAILURE);
			}
			nbytes_total += nbytes_last;
		}
		/* Read the response. */
		while ((nbytes_total = read(sock, buffer, BUFSIZ)) > 0) {
			if (nbytes_total > 0)
					{
						Response += std::string(buffer);
						if (Response.size() > MAX_FILE_SIZE)
							break;
			}
			else
					break;
		}
		if (nbytes_total == -1) {
			perror("read");
			exit(EXIT_FAILURE);
		}
}
void Sock::POST_fileupload(std::string &path, std::string &Response,const char * data){
	Response.clear();
	char request_template[65500];
	snprintf(request_template,65500,"POST %s HTTP/1.1\r\nHost: %s\r\nUser-Agent: curl/7.74.0\r\nAccept: */*\r\nAccept-Encoding: gzip, deflate\r\nContent-Type: multipart/form-data; boundary=---------------------------310808824910080201751194122127\r\nContent-Length: %ld\r\n\r\n%s",path.c_str(),hostname.c_str(), strlen(data),data);
	char request[65500];
	int request_len = snprintf(request, 65500, request_template, hostname);
	if (request_len >= 65500) {
	        fprintf(stderr, "request length large: %d\n", request_len);
	        exit(EXIT_FAILURE);
	}
	ssize_t nbytes_total, nbytes_last;
	char buffer[BUFSIZ];
	memset(buffer, 0, strlen(buffer));
	/* Send HTTP request. */
	nbytes_total = 0;
	while (nbytes_total < request_len) {
		nbytes_last = write(sock, request + nbytes_total, request_len - nbytes_total);
		if (nbytes_last == -1) {
			perror("write");
			exit(EXIT_FAILURE);
		}
		nbytes_total += nbytes_last;
	}
	/* Read the response. */
	while ((nbytes_total = read(sock, buffer, BUFSIZ)) > 0) {
		Response += std::string(buffer);
		if (Response.size() > MAX_FILE_SIZE)
			break;
	}
	if (nbytes_total == -1) {
		perror("read");
		exit(EXIT_FAILURE);
	}
}

Sock::~Sock() {
#if defined(_WIN32) || defined(_WIN64)
    closesocket(sock);
    WSACleanup();
#else
	close(sock);
#endif
	//print ("Destructor called");
}

